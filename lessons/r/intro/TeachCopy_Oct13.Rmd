---
title: "Intro_R_Oct8_2021"
author: "Tara"
date: "10/8/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Welcome

 - **Authors**: Tara Henechowicz adapted from plans by Margot Lautens and Luke Johnston
 - **Research field**: Neuroscience (Music and Health)
 - **Lesson topic**: Intro to R, some data wrangling, statistics, and some visualization
 - **Lesson content URL**: <https://github.com/UofTCoders/studyGroup/tree/gh-pages/lessons/r/intro>

#Why should we use R? 
- reproducible science 
- wonderful packages to help you for working with your data (even datasets that are very big)!
- packages specific to disciplines: biology, genetics, even neuroimaging
- can customize and create reports with RMarkdown. 

#What can we do with R? 
- Organize: Tidy data
- Analyze: statistics, machine learning, field-specific techniques
- Visualize

#Starting with R - the command line

##Command Line

The command line executes code like a calculator but does not keep a record of your work. 
Try entering 2+2 in the commandline, what is the output? 

Now lets save 4 as a variable a. The way we do this in R is typing `a <- 4` in the command line. Here the `<-` is acting as an = sign. 

In summary, you can execute code in the command line, but you will need to scroll back to see the previous code you executed. To reproduce your code, you will need to create a script. 

##Scripts
The type of script we are working in is called and .Rmd file it is an R Markdown script. THis script is helpful for building reports which can later be rendered as a pdf or html file. 

Below is a `code chunk`, where you keep a record of your code and you can execute that code. Anything outside of the code can be used as text to supplement your report or write notes about your process. You can open a code chunk using the `Insert` button or using the short cut for your device. 

Try running the code chunk below by pressing the green play button. 
```{r}
#this is a comment, this will not run as code. 
#Assign the value of 4 to variable "a"
a<-4
#return the value of a
print(a)
#Ask r if 2+2 is equal to "a"
2+2==a
```

##Other windows in R
- Environment: all the variables we have saved, our functions, and libraries we have loaded
- History
- Files
- Help 

#Starting your script
1. Set our "working directory", this means we are telling R where to take files from and where to write them. 
2. Load in the packages we need to use for our project. 
If we don't have the package installed already, you will use the `install.packages` function.
Whether you have the package or not, you will load the package using the `library` function.
```{r}
#Load in the tidyverse amd Using R libraries
library(tidyverse)
library(UsingR)
```

3. Load in our data.
We will be using a dataset that is already in R, so lets take a look at `babies` and try to store as variable `df` in our environment.
```{r}
#call the babies dataset
babies
#we still need to store this dataset in our R environment
df <- babies
```

Now if we call df, we can see we have the babies dataset 
```{r}
#viewing df
view(df)
#OR
df
```

Lets use the function write.csv to take that data and save it as a .csv file in our current directory

```{r}
write.csv(babies, "babies.csv")
```

A few ways to lad data are to:
- manually use the import dataset button in Rstudio (and copy the code from the output)
- use `read_csv()` function from readr package
```{r}
#copy the code generated by the import dataset button
library(readr)
babies2 <- read_csv("babies.csv")
View(babies)
```

#Viewing the data and its structure

1. Instead of viewing the whole dataset we can use the `head` function to view the first 6 rows of the data. 
2. If you want to view more rows of data, use the argument n= to change the size of the table returned. 
```{r}
#view the whole dataset
view(df)
#use the head function to view the first 6 rows of the data
head(df)
#Look at the first 10 rows of the data
head(df, n=10)
```

3. Another important function is `str` it returns the structure of the object. For a `data.frame` that we have here, it will also give you the column names and the structure of those columns. 
`dim` is also a useful function that will retrun the dimesnions of your data.frame.
`names()` shows the column names.
`glimpse()` is a `dplyr` only function that ressembles `str` but unlike `str`
it allows you to see all your columns.
`row.names()` or `rownames()` will return a vector of the rownames of the dataset. However, only `rownames()`can be changed, we will return to the uses of this function later. 

```{r}
#use the str() function on df
str(df)
#use the dim() function to return the size of df
dim(df)
#use names() to return the column names
names(df)
#use row.names() or rownames() to return a vector of the rownames
row.names(df)
```

#Summary statistics and exploring patterns

1. `summary()` shows a quick description of the summary statistics (means, 
median, frequency)for each of your columns.  

This function is especially useful for finding issues in the data coding and in the data structure.
For example, look at the variable sex - is there is something strange here?
Are there any other variables that might have issues?
These are all issues we can fix when we tidy the data, we will return to data tidying in the next section. 
```{r}
#give a summary of df
summary(df)
```

2. Plotting to explore the data

Before we plot any of the columns, we need to know how to select columns from the dataset. 
To call a column of the data we can use the $ operator: df$sex will give us the sex column. 
With dataframes, we can call specific rows and collumns using the index. For example with df[1,6], will give us the 1st row and the 6th column. We can also select a range of columns or rows using `:` operator. 

```{r}
#Try calling the wt column using the `$`
df$wt
#Try another way to get the wt column
df[,7]
#Try to get the first ten rows of the weight column
df[1:10,7]
```


2. There are some base functions that allow us to visualize our data:
`hist()` will provide a historgram of a variable.
`plot()` can allow you to compare two variables, x and y, in many different types of plots. 

```{r}
#Try plotting wt as a histogram
hist(df$wt)
#try plotting ht as the x variable and wt as the y variable
plot(x=df$ht, y=df$wt)
#Now lets use the help function ? to view the plot function
?plot
#Lets try changing the type argument
plot(x=df$ht, y=df$wt, type = "l")
```

#Introduction to data tidying and tidyverse

1. When we looked at the `summary()` of our data, we found that some variables were coded as numeric, when they should be binary or categorical (factors).
`as.logical()` will transform the variable into a logical `TRUE` or `FALSE`
`as.numeric()` will transform the variable into a numeric variable
`as.character()` will transform the variable into character strings
`as.factor()` will transform the variable into a factor. However, the levels will be created automatically and might not be the correct order. You might want to use `factor()` to change the variable. 

```{r}
#lets take a look at the summary again
summary(df)
#let's look at what the coding should be for the variables in babies by looking at the data key
?babies
#Sex is a factor with 3 levels, 1,2,9
as.factor(df$sex)
#only one level is showing, let's use factor() to and set levels = c("1","0")
factor(df$sex, levels = c("1", "2", "9"))
#now we have to save our new variable 
df$sex <- factor(df$sex, levels = c("1", "2", "9"))

```

Try it yourself:
1. check the data key on the babies data set using ?babies and look at the variable marital
2. change the variable marital to a character 
3. look at the summary of marital as a character variable
4. now change marital to a factor
5. look at the summary of marital as a factor, what is the difference between the summary if marital is a character or a factor?
```{r}

```

2. There are many helpful functions to deal with missing data in R.
You might want to check how many missing values there are using `is.na()` or remove missing all rows of data using `na.omit()`.

Sometimes you will receive datasets where NAs are missing and othertimes the coders have used key to notate NAs. In the babies dataset, NAs in the wt column are coded as 999. We saw this when we visualized wt and ht.

```{r}
plot(df$wt, df$ht)
```


For this dataset, in the ht column, NAs are coded as 99.
We want to create a statement telling R that if df$ht is equal to 99, we want to rewrite that code as NA, if that is not TRUE, then keep the original output. 
This is called an ifelse statement. An easy way to do this in R is using the `ifelse()` function. The first value is the statement of what we are looking for, `df$ht==99`, the next value will be what we should do if that statement is `TRUE`, the third value will be what to do if the statement is `FALSE`. 
Once we have the 99s coded as NA, we can count the number of NAs in the vector using `is.na()`. 
Lastly, we can remove rows that have NAs using `na.omit()`.
```{r}
#Use the ifelse() function to tell R to replace df$ht values that are 99 with NA. 
ifelse(df$ht == 99, NA, df$ht)
#Store the new variable back into df$ht
df$ht <- ifelse(df$ht == 99, NA, df$ht)
#To count the number of NAs 
summary(is.na(df$ht))
#To remove the rows that have NA in them from the dataset, we can use the na.omit() function
na.omit(df)
#Let's store the  df with NAs omited into a new data frame, name it df2
df2 <- na.omit(df)

```

#Introduction to Tidyverse

Data wrangling is a bit tedious in base R. At the beginning of the session we loaded in a great collection of packages, `tidyverse` designed to make this easier.  Load packages by using the `library()`
function.  `dplyr` allows for easy manipulation of datasets.

`select` is a `dplyr` function that lets us select columns from the dataset. 

Columns can be selected
individually with `,`, in a series with `:` or removed with `-`.
```{r wrangleSelect}
#The first two  lines of code are the same. 
dplyr::select(df,id,pluralty,outcome,date)
dplyr::select(df, id:date)

#This line of code selects all columns except ht and wt.
dplyr::select(df,-ht, -wt)
```

`dplyr` also comes with a `%>%` pipe function (via the
`magrittr` package), which works similar to how the Bash shell `|`
pipe works. The command on the right-hand side takes the output from
the command on the left-hand side, just like how a plumbing pipe works
for water. The `.` object represents the output from the pipe, but it 
doesn't have to be used as using `%>%` implies also using `.`.

```{r wranglePipe}

#The outputs of each of these two lines of code are the same. 
df %>% 
  dplyr::select(id,pluralty,outcome,date)
df %>%
  dplyr::select(id:date)

#This line of code selects all columns except ht and wt.
df %>%
  dplyr::select(-ht, -wt)
```

You can rename columns either using `rename` or `select` (the new name
is on the left hand side, so `newname = oldname`).  However, with the
`select` command, only that column gets selected, while `rename`
selects all columns.

```{r wrangleRename}

df %>% rename(weight = wt)
df %>% dplyr::select(weight = wt)
```

You can subset the dataset using `filter`.  Note the double equal sign
`==` for testing if 'Examination' is equal to 15.  A single `=` is
used for something else (assigning things to objects). Use `&` or `,`
to apply multiple filters.

```{r wrangleFilter}
#find the babies that have a weight that equal to 100 grams
filter(df,wt==100)
#find the babies that have a weight that are greater than 100 grams
df %>% filter(wt>100)
#filter for marital status does not equal 1
df %>% filter(marital!=1)

## These are all the same:
df %>% filter(wt>100)  %>% filter(marital!=1)
df %>% filter(wt>100 , marital!=1)
df %>% filter(wt>100 & marital!=1)
```

We can start chaining these commands together using the `%>%` command.
There is no limit to how long a chain can be. `mutate` creates a new column. 

```{r wrangleChain}
df %>%
  filter(wt>100) %>% 
  mutate(hwratio = wt/ht) %>% 
  dplyr::select(-ht, -wt) 
```

R is very powerful at analyzing data but is biased. To get your data into a nicer and more analyable format, you can use the `tidyverse` package.  
See what `gather` does in the code below.  Then see what `spread` does.  

```{r reorg}
## Compare this:
df
## With this:
df %>%
  gather(ht,wt, key ="variable", value = "grams")

## And back again:
df %>%
  gather(ht,wt, key ="variable", value = "grams") %>% 
  spread(variable, grams) 

```

Combined with `dplyr`'s `group_by` and `summarise` you can quickly
summarise data or do further, more complicated analyses. `group_by`
makes it so further analyses or operations work on the groups.
`summarise` transforms the data to only contain the new variable(s)
created, in this case the mean. You can try out `max()`,`min()`,`median()` and `sd()`.

```{r reorgChain}
df %>%
  group_by(smoke) %>% #group by smoking status
  summarise(mean = mean(wt)) #summarize the mean

```

#show how to knit using knit button

